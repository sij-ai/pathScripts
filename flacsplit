#!/bin/bash

# Script version
VERSION="2.3"

# Default options
FORCE=false
VERBOSE=false
DRY_RUN=false
OUTPUT_FORMAT="%n - %t"
KEEP_ORIGINAL=false
SKIP_VALIDATION=false

# Global variable for APE handling method
APE_METHOD="none"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to show usage
usage() {
    cat << EOF
Usage: flacsplit [OPTIONS] [directory]

Split FLAC/APE files with CUE sheets into individual FLAC tracks.

OPTIONS:
    -f, --force             Overwrite existing output files
    -v, --verbose           Enable verbose output
    -n, --dry-run           Show what would be done without executing
    -t, --format FORMAT     Set track naming format (default: "%n - %t")
    -k, --keep              Keep original audio/CUE files after split
    --skip-validation       Skip CUE file validation
    -h, --help              Show this help message
    --version               Show version information

ARGUMENTS:
    directory               Directory to process (default: current directory)

SUPPORTED FORMATS:
    Input:  FLAC (.flac), Monkey's Audio (.ape)
    Output: FLAC (.flac)

NOTE: APE files are converted to FLAC using ffmpeg before splitting.

EXAMPLES:
    flacsplit                           # Process current directory
    flacsplit /path/to/albums           # Process specific directory
    flacsplit -f -v ~/Music             # Force overwrite with verbose output
    flacsplit -n ~/Music                # Dry run to see what would happen
    flacsplit -t "%02n. %t" ~/Music     # Custom track naming format
    flacsplit -k ~/Music                # Keep original files after splitting

EOF
    exit 1
}

# Function to print colored output
print_color() {
    local color=$1
    shift
    echo -e "${color}$*${NC}"
}

# Function to log messages
log() {
    [[ $VERBOSE == true ]] && print_color "$BLUE" "[INFO] $*"
}

# Function to check available disk space
check_disk_space() {
    local file="$1"
    local output_dir="$2"
    
    local file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
    # For APE files, estimate FLAC will be similar size (need extra space for conversion)
    local required_space=$((file_size * 2))
    local available_space=$(df "$(dirname "$output_dir")" | awk 'NR==2 {print $4 * 1024}')
    
    if [[ $required_space -gt $available_space ]]; then
        print_color "$RED" "Error: Insufficient disk space for $file"
        return 1
    fi
    return 0
}

# Function to validate CUE file (handles indentation)
validate_cue() {
    local cue_file="$1"
    
    # Check for TRACK entries (allow leading spaces/tabs)
    if ! grep -q "^[[:space:]]*TRACK" "$cue_file"; then
        print_color "$YELLOW" "Warning: $cue_file doesn't appear to contain track information"
        return 1
    fi
    
    # Check for FILE entries (allow leading spaces/tabs)
    if ! grep -q "^[[:space:]]*FILE" "$cue_file"; then
        print_color "$YELLOW" "Warning: $cue_file doesn't specify a source file"
        return 1
    fi
    
    return 0
}

# Function to check dependencies
check_deps() {
    local missing=0
    local deps=("shnsplit" "flac" "stat" "df")
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            case $dep in
                shnsplit) print_color "$RED" "Error: 'shnsplit' not found. Install with: apt install shntool" ;;
                flac) print_color "$RED" "Error: 'flac' not found. Install with: apt install flac" ;;
                *) print_color "$RED" "Error: '$dep' not found." ;;
            esac
            missing=1
        fi
    done
    
    [[ $missing -eq 1 ]] && exit 1
    
    # Check for APE support (mac or ffmpeg)
    if command -v mac &> /dev/null; then
        APE_METHOD="mac"
        log "Using 'mac' decoder for APE files"
    elif command -v ffmpeg &> /dev/null; then
        APE_METHOD="ffmpeg"
        log "Using 'ffmpeg' for APE file conversion"
    else
        APE_METHOD="none"
        print_color "$YELLOW" "Warning: Neither 'mac' nor 'ffmpeg' found."
        print_color "$YELLOW" "APE files will be skipped. Install with: apt install ffmpeg"
    fi
}

# Function to convert APE to temporary FLAC using ffmpeg
convert_ape_to_flac() {
    local ape_file="$1"
    local temp_flac="${ape_file%.*}.ape_converted.flac"
    
    print_color "$BLUE" "Converting APE to FLAC..."
    log "Output: $temp_flac"
    
    if [[ $VERBOSE == true ]]; then
        if ! ffmpeg -i "$ape_file" -c:a flac "$temp_flac" -y 2>&1; then
            print_color "$RED" "Error: Failed to convert APE file"
            return 1
        fi
    else
        if ! ffmpeg -i "$ape_file" -c:a flac "$temp_flac" -y -loglevel error 2>&1; then
            print_color "$RED" "Error: Failed to convert APE file"
            return 1
        fi
    fi
    
    echo "$temp_flac"
    return 0
}

# Function to process a single audio file
process_audio_file() {
    local audio_file="$1"
    local cue_file="${audio_file%.*}.cue"
    local base_name=$(basename "${audio_file%.*}")
    local dir_name="$(dirname "$audio_file")"
    local file_ext="${audio_file##*.}"
    local temp_original="${audio_file}.original_temp"
    local processing_file=""
    local temp_flac_from_ape=""
    
    # Skip APE files if no decoder is available
    if [[ "${file_ext,,}" == "ape" ]] && [[ $APE_METHOD == "none" ]]; then
        print_color "$YELLOW" "Skipping $audio_file (no APE decoder available)"
        return 1
    fi
    
    # Check if CUE file exists
    if [[ ! -f "$cue_file" ]]; then
        log "Skipping $audio_file (no matching CUE file)"
        return 1
    fi
    
    # Validate CUE file (unless skipped)
    if [[ $SKIP_VALIDATION != true ]] && ! validate_cue "$cue_file"; then
        print_color "$YELLOW" "Warning: CUE file validation failed for $cue_file"
        read -p "Continue anyway? (y/N): " -n 1 -r
        echo
        [[ ! $REPLY =~ ^[Yy]$ ]] && return 1
    fi
    
    # Check disk space
    if ! check_disk_space "$audio_file" "$dir_name"; then
        return 1
    fi
    
    print_color "$GREEN" "Processing: $audio_file"
    log "Format: ${file_ext^^}"
    log "CUE file: $cue_file"
    log "Output directory: $dir_name"
    log "Track format: $OUTPUT_FORMAT"
    
    if [[ $DRY_RUN == true ]]; then
        if [[ "${file_ext,,}" == "ape" ]] && [[ $APE_METHOD == "ffmpeg" ]]; then
            print_color "$BLUE" "[DRY RUN] Would convert APE to FLAC"
        fi
        print_color "$BLUE" "[DRY RUN] Would split $audio_file into $dir_name"
        [[ $KEEP_ORIGINAL != true ]] && print_color "$BLUE" "[DRY RUN] Would delete $audio_file and $cue_file"
        return 0
    fi
    
    # Handle APE files - convert to FLAC first if using ffmpeg
    if [[ "${file_ext,,}" == "ape" ]]; then
        if [[ $APE_METHOD == "ffmpeg" ]]; then
            # Rename original APE to temp name
            log "Renaming original APE file to temporary name: $temp_original"
            if ! mv "$audio_file" "$temp_original"; then
                print_color "$RED" "Error: Failed to rename $audio_file"
                return 1
            fi
            
            # Convert APE to FLAC
            temp_flac_from_ape=$(convert_ape_to_flac "$temp_original")
            if [[ $? -ne 0 ]] || [[ ! -f "$temp_flac_from_ape" ]]; then
                print_color "$RED" "Error: APE to FLAC conversion failed"
                mv "$temp_original" "$audio_file"
                return 1
            fi
            
            processing_file="$temp_flac_from_ape"
            log "Conversion complete, processing converted FLAC"
        else
            # Using mac decoder - rename original and use directly
            log "Renaming original file to temporary name: $temp_original"
            if ! mv "$audio_file" "$temp_original"; then
                print_color "$RED" "Error: Failed to rename $audio_file"
                return 1
            fi
            processing_file="$temp_original"
        fi
    else
        # FLAC file - rename to temp name
        log "Renaming original file to temporary name: $temp_original"
        if ! mv "$audio_file" "$temp_original"; then
            print_color "$RED" "Error: Failed to rename $audio_file"
            return 1
        fi
        processing_file="$temp_original"
    fi
    
    # Count existing FLAC files before split
    local files_before=$(find "$dir_name" -maxdepth 1 -name "*.flac" -type f ! -name "*.original_temp" ! -name "*.ape_converted.flac" 2>/dev/null | wc -l)
    
    # Split the audio file into the same directory
    log "Running: shnsplit -f '$cue_file' -t '$OUTPUT_FORMAT' -o flac '$processing_file' -d '$dir_name'"
    
    # Capture output and errors
    local split_output
    local split_exit_code
    if [[ $VERBOSE == true ]]; then
        shnsplit -f "$cue_file" -t "$OUTPUT_FORMAT" -o flac "$processing_file" -d "$dir_name"
        split_exit_code=$?
    else
        split_output=$(shnsplit -f "$cue_file" -t "$OUTPUT_FORMAT" -o flac "$processing_file" -d "$dir_name" 2>&1)
        split_exit_code=$?
    fi
    
    # Count FLAC files after split (excluding temp files)
    local files_after=$(find "$dir_name" -maxdepth 1 -name "*.flac" -type f ! -name "*.original_temp" ! -name "*.ape_converted.flac" 2>/dev/null | wc -l)
    local track_count=$((files_after - files_before))
    
    # Check if we actually got new tracks
    if [[ $track_count -le 0 ]]; then
        print_color "$RED" "Error: No tracks generated for $audio_file"
        if [[ -n "$split_output" ]]; then
            print_color "$RED" "shnsplit output: $split_output"
        fi
        # Cleanup and restore
        [[ -f "$temp_flac_from_ape" ]] && rm "$temp_flac_from_ape"
        [[ -f "$temp_original" ]] && mv "$temp_original" "$audio_file"
        return 1
    fi
    
    # Warn about non-zero exit but continue if tracks were created
    if [[ $split_exit_code -ne 0 ]]; then
        log "Warning: shnsplit exited with code $split_exit_code, but $track_count tracks were created"
    fi
    
    print_color "$GREEN" "✓ Successfully split into $track_count tracks"
    
    # Cleanup temporary files and originals
    if [[ $KEEP_ORIGINAL == true ]]; then
        log "Restoring original file: $audio_file"
        [[ -f "$temp_flac_from_ape" ]] && rm "$temp_flac_from_ape"
        [[ -f "$temp_original" ]] && mv "$temp_original" "$audio_file"
    else
        log "Deleting original and temporary files"
        [[ -f "$temp_flac_from_ape" ]] && rm "$temp_flac_from_ape"
        [[ -f "$temp_original" ]] && rm "$temp_original"
        [[ -f "$cue_file" ]] && rm "$cue_file"
    fi
    
    return 0
}

# Main function to process directories recursively
process_directory() {
    local dir="$1"
    local count=0
    local total=0
    
    # Count total audio files first (both FLAC and APE)
    while IFS= read -r -d '' audio_file; do
        local cue_file="${audio_file%.*}.cue"
        local file_ext="${audio_file##*.}"
        
        # Skip APE files if no decoder available
        if [[ "${file_ext,,}" == "ape" ]] && [[ $APE_METHOD == "none" ]]; then
            continue
        fi
        
        [[ -f "$cue_file" ]] && ((total++))
    done < <(find "$dir" -type f \( -name "*.flac" -o -name "*.ape" \) -print0)
    
    if [[ $total -eq 0 ]]; then
        print_color "$YELLOW" "No FLAC/APE files with matching CUE sheets found in $dir"
        return 0
    fi
    
    print_color "$BLUE" "Found $total audio file(s) with CUE sheets in $dir"
    
    # Process all audio files
    while IFS= read -r -d '' audio_file; do
        if process_audio_file "$audio_file"; then
            ((count++))
        fi
        
        # Progress indicator
        local current=$((count + 1))
        if [[ $VERBOSE == true ]] && [[ $current -le $total ]]; then
            print_color "$BLUE" "Progress: $current/$total"
        fi
    done < <(find "$dir" -type f \( -name "*.flac" -o -name "*.ape" \) -print0)
    
    if [[ $count -eq 0 ]]; then
        print_color "$YELLOW" "No files were processed"
    else
        print_color "$GREEN" "✓ Successfully processed $count/$total album(s)"
    fi
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -f|--force)
            FORCE=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -n|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -t|--format)
            OUTPUT_FORMAT="$2"
            shift 2
            ;;
        -k|--keep)
            KEEP_ORIGINAL=true
            shift
            ;;
        --skip-validation)
            SKIP_VALIDATION=true
            shift
            ;;
        -h|--help)
            usage
            ;;
        --version)
            echo "flacsplit version $VERSION"
            exit 0
            ;;
        -*)
            print_color "$RED" "Unknown option: $1"
            usage
            ;;
        *)
            TARGET_DIR="$1"
            shift
            ;;
    esac
done

# Main execution
print_color "$BLUE" "flacsplit v$VERSION"

# Check dependencies first
check_deps

# Handle directory argument
TARGET_DIR="${TARGET_DIR:-.}"

# Verify directory exists
if [[ ! -d "$TARGET_DIR" ]]; then
    print_color "$RED" "Error: Directory '$TARGET_DIR' not found"
    exit 1
fi

# Show configuration if verbose
if [[ $VERBOSE == true ]]; then
    print_color "$BLUE" "Configuration:"
    echo "  Target directory: $TARGET_DIR"
    echo "  Force overwrite: $FORCE"
    echo "  Dry run: $DRY_RUN"
    echo "  Output format: $OUTPUT_FORMAT"
    echo "  Keep originals: $KEEP_ORIGINAL"
    echo "  Skip validation: $SKIP_VALIDATION"
    echo "  APE decoder: $APE_METHOD"
    echo
fi

# Process the directory recursively
process_directory "$(realpath "$TARGET_DIR")"
